
у нас будет сложная задача!!!
интерпритатор scheme 
ух ух ух

с чем надо определиться

1. Подмножество языка scheme которое будем реализовывать
2. Написать тестовые программы на (1).  
	Пробуем их на racket, ну или кому-то что-то ???
3. Написать собственный интерпретатор scheme
4. Проверить его работоспособность

в parsec есть удобные вещи для этого

Новые факторы по сравению с прошлым

основные грабли

1) написать интерпретатор пространства видимости имен
	scope(environment)
2) передача аргументов функциям
3) функции высш порядков
   лямбда функции	



Для ленивых и боязливых

*Запасной вариант -
Осуществить перевод исходника на scheme в haskell

единственное различие - именование функций, в остальном все просто

ну а те кто все еще с нами - продолжим

Определимся с  чем хотели

1. функции для списков
	cons
	cdr	- хвост
	car 	- голова
	null? 	- проверка списка на пустоту
	вообще "?" функции которые выполняют проверку аргумента
	list 	- сотворить список
	quote	- цитирование

	конструкции 
	lambda
	define
		условные
		if
		cond
		let

	кстати местами используются квадратные скобки(особенно racket), они равнозначны круглым но все же

	(+ 1 1 1 1) -> 4
	чтоб работало

	это можно обобщить fold -ами
	см 	foldr 	foldr 	fold1	

	унарный минус (взятие числа с противоположным знаком)


	Операции
	or
	and
	> 	< 	>= 	<=	
	not
	#t #f

	remainder - остаток от деления
	sqrt

	примем соглашение о типе результатов этих функций

	ограничимся двумя числовыми типами - Integer и Double 
	I+I=I
	I+I+...+D+...+I+...+I= D

	деление по умолчанию - D

	Ограничиться чистыми функциями, ну про это еще потом поговорим

	написать функции
	even
	odd
	встроенные они или нет - по нашему усмотрениюэ

	apply - противоположная quote функция , сначала потестировать и понять что это блять вообще такое

2.
	define

	(define unit 1)

	(+ unit 1)
	>2

	можно обьявить ф-ю

	(define (inc x) (+ x 1)) // 1й аргумент - обьявление, 2 - определение

	(inc unit)
	>2

	define сама по себе ничего не делает. Она изменяет среду выполнения

	как и в форте, при нахождении особого слова мы ищем в словаре что подставить 

	в данном случае видит 
	(inc unit)
	->
	(inc 1)

	когда видим круглую скобку, голова списка - функция, хвост - аргументы

	перед тем как что-то подставить, мы начинаем квн, пардон вычислять эти аргументы

	(define (f1 ...(...)))

	(begin
		(...)
		(...)
		(...))

	begin последовательо все вычисляет а возвращает реультат последнего выражения

	(define (f x)
		(begin
			(define (^2 x) (* x x))
			(define (^3 x) (* x x x))
		(- (^3 x) (^2 x)))

	надо еще реализовать let , оговорочка , по желанию	

	строки в кавычках можно организовать


какие тесты на scheme
	fib
	fact
	проверка на простоту

	свои версии  map и filter

(atom1 atom2 atom3)
atom это

имя функции
значение
	 Integer
	 Double
	 String
	 Bool
	 Void

обьекты языка scheme мб представлены
data Expr =
	списком  	List [Expr]
	целым		integer
	...			Double
	...			Void
	Name		String - имя определения




интерпретация 

|парсинг -> дерево      			parser ->(free)->eval
|парсинг							parser


если видим список пытаемся его вычислить

по поводу передачи аргументов

можно через стек как всегда 

можно чере таблицу соответствий - пам пам


функцию с именем fn  применяем к состоянию среды  env и аргументам args


Итак программа принимает файл на scheme 
вывод в терминал 

программа -
	сначала определение 
	потом использование 

хотя впринципе должно работать вперемешку



